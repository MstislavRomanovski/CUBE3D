#define _USE_MATH_DEFINES
#include<cmath>
#include <SFML/Graphics.hpp>
#include <vector>
#include <list>
#include <random>


using namespace sf;
using namespace std;

struct vector3
{
    float x,y,z;

};
struct connection
{
    int a,b,c,d;
};

struct connection2
{
    int a;
    int b;
};
VertexArray build_cube2(vector<vector3>& points, vector<connection2>& connections, int w, int h)
{
    int lenlist = connections.size();
    VertexArray line(Lines, lenlist * 2);
    int i = 0;
    for (auto& conn : connections)
    {
        /*
        float x1 = w/2 + (focus_len * points[conn.a].x)/(focus_len + points[conn.a].z) * 100;
        float y1 = h / 2 + (focus_len * points[conn.a].y) / (focus_len + points[conn.a].z) * 100;
        float x2 = w / 2 + (focus_len * points[conn.b].x) / (focus_len + points[conn.b].z) * 100;
        float y2 = h / 2 + (focus_len * points[conn.b].y) / (focus_len + points[conn.b].z) * 100; */
        float x1 = w / 2 + (points[conn.a].x) * 100;
        float y1 = h / 2 + (points[conn.a].y) * 100;
        float x2 = w / 2 + (points[conn.b].x) * 100;
        float y2 = h / 2 + (points[conn.b].y) * 100;
        line[i].position = Vector2f(x1, y1);
        line[i + 1].position = Vector2f(x2, y2);
        i += 2;
    }
    return line;
}

float centroid_z(vector<vector3>& points)
{
    float avgz = 0;
    float c = 0;
    for (auto& vec : points)
    {
        avgz += vec.z;
        c++;
    }
    return avgz / c;
}

void build_cube(list<ConvexShape>* list,vector<vector3>& points, vector<connection>& connections, int w, int h, vector3* color)
{
    //int lenlist = connections.size();
    
    //face.setPointCount(4);
    int start = 0;
    int end = 255;
    int transparency = 1000;

    int val1 = 0;
    int val2 = 0;
    int val3 = 0;

    for (auto& conn : connections)
    {
        ConvexShape* face = new ConvexShape(4);
        /*
        float x1 = w/2 + (focus_len * points[conn.a].x)/(focus_len + points[conn.a].z) * 100;
        float y1 = h / 2 + (focus_len * points[conn.a].y) / (focus_len + points[conn.a].z) * 100;
        float x2 = w / 2 + (focus_len * points[conn.b].x) / (focus_len + points[conn.b].z) * 100;
        float y2 = h / 2 + (focus_len * points[conn.b].y) / (focus_len + points[conn.b].z) * 100; */

        //int rnd1 = rand() % (end - start + 1) + start;
        //int rnd2 = rand() % (end - start + 1) + start;
        //int rnd3 = rand() % (end - start + 1) + start;

        float x1 = w / 2 + (points[conn.a].x) * 100;
        float y1 = h / 2 + (points[conn.a].y)* 100;
        float z1 = points[conn.a].z;

        float x2 = w / 2 + (points[conn.b].x)* 100;
        float y2 = h / 2 + (points[conn.b].y)* 100;

        float x3 = w / 2 + (points[conn.c].x) * 100;
        float y3 = h / 2 + (points[conn.c].y) * 100;

        float x4 = w / 2 + (points[conn.d].x) * 100;
        float y4 = h / 2 + (points[conn.d].y) * 100;

        
        float z = (points[conn.a].z + points[conn.b].z + points[conn.c].z + points[conn.d].z)/4;
        if(z > 0)
        {
            face->setPoint(0, sf::Vector2f(x1, y1));
            face->setPoint(1, sf::Vector2f(x2, y2));
            face->setPoint(2, sf::Vector2f(x3, y3));
            face->setPoint(3, sf::Vector2f(x4, y4));
            face->setFillColor(Color(color->x + val1, color->y + val2, color->z + val3, transparency));
            list->push_back(*face);
        }
        delete face;

        val1 += 10;
        val2 += 20;
        val3 += 60;
        
    }

}

void clearlist(list<ConvexShape>* list)
{
    auto itr = list->begin();
    while (itr != list->end())
    {
        itr = list->erase(itr);
    }


}

void rotate(vector3& point, float x = 0, float y = 0, float z = 0)
{
    float rad = 0;
    rad = x * M_PI/180;// yz rotation
    point.y = cos(rad) * point.y - sin(rad) * point.z;
    point.z = sin(rad) * point.y + cos(rad) * point.z;

    rad = y * M_PI / 180;// xz rotation
    point.x = cos(rad) * point.x - sin(rad) * point.z;
    point.z = sin(rad) * point.x + cos(rad) * point.z;

    rad = z * M_PI / 180; //xy rotation
    point.x = cos(rad) * point.x - sin(rad) * point.y;
    point.y = sin(rad) * point.x + cos(rad) * point.y;
}


void rotate_all(vector<vector3>& points, double a, double b, double c)
{

    for (auto& p : points)
    {

        rotate(p, a, b, c);

    }
}



int main()
{
    int resw = 1024;
    int resh = 1024;
    //float focus_len = 10000;
    vector3 color = {255, 255, 255};
   /* vector<vector3> points{


        {-1,-1,-1},
        {1,-1,-1},
        {1,1,-1},
        {-1,1,-1},

        {-1,-1,1},
        {1,-1,1},
        {1,1,1},
        {-1,1,1}
    }; */

        vector<vector3> points{
        

        {-1,-1,1},
        {1,-1,1},
        {1,1,1},
        {-1,1,1},

        {-1,-1,-1},
        {1,-1,-1},
        {1,1,-1},
        {-1,1,-1},

    };
    vector<connection> connections
    {
        {0,1,2,3},
        {4,5,6,7},
        {0,4,5,1},
        {3,7,6,2},
        {1,5,6,2},
        {0,3,7,4},
    };

    vector<connection2> connections2
    {
        {0,4},
        {1,5},
        {2,6},
        {3,7},

        {0,1},
        {1,2},
        {2,3},
        {3,0},

        {4,5},
        {5,6},
        {6,7},
        {7,4}

    };



    RenderWindow window(VideoMode(resw, resh), L"Новый проект", Style::Default);

    window.setVerticalSyncEnabled(true);
    
    list<ConvexShape> face_list;

    while (window.isOpen())
    {
        Event event;
        
        while (window.pollEvent(event))
        {
            switch (event.type)
            {
            case Event::Closed:
                window.close();

            case sf::Event::KeyPressed:
            {
                if (sf::Keyboard::isKeyPressed(sf::Keyboard::LShift) && sf::Keyboard::isKeyPressed(sf::Keyboard::Right))
                    rotate_all(points, 0.0, 0.0, 0.7);
                else if (sf::Keyboard::isKeyPressed(sf::Keyboard::LShift) && sf::Keyboard::isKeyPressed(sf::Keyboard::Left))
                    rotate_all(points, 0.0, 0.0, -0.7);
                else if(sf::Keyboard::isKeyPressed(sf::Keyboard::Right))
                    rotate_all(points, 0.0, 0.7, 0.0);
                else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Left))
                    rotate_all(points, 0.0, -0.7, 0.0);
                else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Up))
                    rotate_all(points, 0.7, 0.0, 0.0);
                else if (sf::Keyboard::isKeyPressed(sf::Keyboard::Down))
                    rotate_all(points, -0.7, 0.0, 0.0);

                break;
            }


            }
            VertexArray vertexes = build_cube2(points, connections2, resw, resh);
           
            
            build_cube(&face_list,points, connections, resw, resh, &color);
            window.clear(Color::Black);
            auto itr = face_list.begin();
            while (itr != face_list.end())
            {
                ConvexShape tmp = *itr;
                window.draw(tmp);
                itr++;
            }
            //window.draw();
            window.draw(vertexes);
            window.display();
            clearlist(&face_list);

        }
    }
    return 0;
}